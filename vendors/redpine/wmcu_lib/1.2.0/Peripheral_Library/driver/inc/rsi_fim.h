
/**
 * Includes
 */

#ifndef __RSI_FIM_H__
#define __RSI_FIM_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "base_types.h"
#include "rsi_error.h"
#include "RS1xxxx.h"

/**
 * \cond HIDDEN_SYMBOLS 
 */
typedef float float32_t;
	
/**
 @brief 8-bit fractional data type in 1.7 format.
*/
typedef int8_t q7_t;

/**
 * @brief 16-bit fractional data type in 1.15 format.
*/
typedef int16_t q15_t;

/**
 * @brief 32-bit fractional data type in 1.31 format.
*/
typedef int32_t q31_t;

typedef enum 
{
  ULP_FIM_COP_DATA_REAL_REAL = 0,
  ULP_FIM_COP_DATA_CPLX_REAL,
  ULP_FIM_COP_DATA_REAL_CPLX,
  ULP_FIM_COP_DATA_CPLX_CPLX
}typ_data_t;


#define ULP_FIM_COP_START_TRIG        0x01
#define XMAX(x,y)                     (((x) > (y)) ? (x) : (y))
#define MEM_BANK                      0x24060000
#define BANK0                         0x00
#define BANK1                        (0x0800 >> 2)
#define BANK2                        (0x1000 >> 2)
#define BANK3                        (0x1800 >> 2)
#define BANK4                        (0x2000 >> 2) 
#define BANK5                        (0x2800 >> 2)
#define BANK6                        (0x3000 >> 2)
#define BANK7                        (0x3800 >> 2)
#define STRS(sat,trunc,round,shift)  ((round <<16 )|(shift << 10)| (trunc << 5) | sat) 

typedef enum mode
{
	FIR           = 0x01,
	IIR           = 0x02,
	INTERPOLATE   = 0x63,
	ADD_SCALAR    = 0x44,
	SUB_SCALAR    = 0x45,
	MUL_SCALAR    = 0x46,
	ADD_VECTOR    = 0x47,
	SUB_VECTOR    = 0x49,
	MUL_VECTOR    = 0x4A,
	NORM_SQUARE   = 0xAB,
	MUL_MAT       = 0x4C,
}present_mode;

#define  FORMAT_Q7     2
#define  FORMAT_Q15    3
#define  FORMAT_Q31    1
#define  FORMAT_F32    0




/* list of variables for matrix multiplication  */
typedef struct
{
	 int16_t nRows;
	 int16_t nColumns;
	 int32_t *pData;
}arm_matrix_instance_f32_opt;


typedef struct
{
	 uint16_t nRows;
	 uint16_t nColumns;
	 q31_t *pData;
}arm_matrix_instance_q31_opt;

typedef struct
{
	 int16_t nRows;
	 int16_t nColumns;
	 q15_t *pData;
}arm_matrix_instance_q15_opt;

/* list of variables for fir filter */
typedef struct
{
	uint16_t 	numTaps;
	int32_t *pState;
	int32_t *pCoeffs;
} arm_fir_instance_f32_opt;



typedef struct
{
	uint16_t 	numTaps;
	q31_t *pState;
	q31_t *pCoeffs;
}arm_fir_instance_q31_opt;


typedef struct
{
	uint16_t 	numTaps;
	q15_t *pState;
	q15_t *pCoeffs;
}arm_fir_instance_q15_opt;


typedef struct
{
	uint16_t 	numTaps;
	q7_t *pState;
	q7_t *pCoeffs;
}arm_fir_instance_q7_opt;



/* list of variables for Iir filter */
typedef struct
{
	uint16_t 	numStages;
  int32_t *pState;
  int32_t *pkCoeffs;
  int32_t *pvCoeffs;
}fim_iir_instance_f32;

typedef struct
{
	uint16_t 	numStages;
  q31_t *pState;
  q31_t *pkCoeffs;
  q31_t *pvCoeffs;
}fim_iir_instance_q31;


typedef struct
{
	uint16_t 	numStages;
  q15_t *pState;
  q15_t *pkCoeffs;
  q15_t *pvCoeffs;
}fim_iir_instance_q15;

typedef struct
{
  uint8_t L;                      /**< upsample factor. */
  uint16_t phaseLength;           /**< length of each polyphase filter component. */
  int32_t *pCoeffs;               /**< points to the coefficient array. The array is of length L*phaseLength. */
  int32_t *pState;                /**< points to the state variable array. The array is of length phaseLength+numTaps-1. */
} arm_fir_interpolate_instance_f32_opt;

typedef enum
{
  ARM_MATH_SUCCESS = 0,                /**< No error */
  ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
  ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
  ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation. */
  ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
  ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is singular and cannot be inverted. */
  ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
} arm_status;

/**
 * @brief Instance structure for the Q15 FIR interpolator.
 */
typedef struct
{
  uint8_t L;                      /**< upsample factor. */
  uint16_t phaseLength;           /**< length of each polyphase filter component. */
  q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*phaseLength. */
  q15_t *pState;                  /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
} arm_fir_interpolate_instance_q15_opt;


/**
 * @brief Instance structure for the Q31 FIR interpolator.
 */
typedef struct
{
  uint8_t L;                      /**< upsample factor. */
  uint16_t phaseLength;           /**< length of each polyphase filter component. */
  q31_t *pCoeffs;                  /**< points to the coefficient array. The array is of length L*phaseLength. */
  q31_t *pState;                   /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
} arm_fir_interpolate_instance_q31_opt;

/**
 * \endcond
 */

/*************** FIM Function Prototypes **************/

void rsi_arm_offset_f32_opt( int32_t *pSrc, int32_t scale, int32_t *pDst,
                         uint32_t length,uint16_t inBank, uint16_t outBank );

void rsi_arm_offset_q7_opt( q7_t *pSrc, q7_t scale, q7_t *pDst, uint32_t length,uint16_t inBank, uint16_t outBank);

void rsi_arm_offset_q15_opt( q15_t *pSrc, q15_t scale, q15_t *pDst, uint32_t length,uint16_t inBank, uint16_t outBank);

void rsi_arm_offset_q31_opt( q31_t *pSrc, q31_t scale, q31_t *pDst, uint32_t length,uint16_t inBank, uint16_t outBank);

void rsi_fim_scalar_add_q15( q15_t *pSrc,q15_t *scale,uint32_t blockSize, typ_data_t typ_data,uint16_t inBank, uint16_t outBank);

void rsi_fim_scalar_sub_q7(q7_t *pSrc,q7_t scale,q7_t *pDst, uint32_t blockSize,uint16_t inBank, uint16_t outBank);

void rsi_fim_scalar_sub_q15(q15_t *pSrc,q15_t *scale, q15_t *pDst,uint32_t blockSize, typ_data_t typ_data,uint16_t inBank, uint16_t outBank);

void rsi_fim_scalar_sub_q31(q31_t *pSrc,q31_t scale,q31_t *pDst, uint32_t blockSize,uint16_t inBank, uint16_t outBank);

void rsi_fim_scalar_sub_f32( int32_t *pSrc,int32_t scale,int32_t *pDst, uint32_t length,uint16_t inBank, uint16_t outBank);
                                                                 
void rsi_arm_scale_f32_opt( int32_t *pSrc,int32_t scale,int32_t *pDst, uint32_t length,uint16_t inBank, uint16_t outBank);
                        
void rsi_arm_scale_q7_opt( q7_t *pSrc,q7_t scaleFract,int8_t shift,q7_t *pDst,uint32_t blockSize,uint16_t inBank, uint16_t outBank);
                       
void rsi_arm_scale_q15_opt( q15_t *pSrc, q15_t scaleFract, int8_t shift,q15_t *pDst, uint32_t blockSize,uint16_t inBank, uint16_t outBank);
                       
void rsi_arm_scale_q31_opt( q31_t * pSrc, q31_t scaleFract, int8_t shift, q31_t * pDst,uint32_t blockSize,uint16_t inBank, uint16_t outBank);
                       
void rsi_fim_scalar_mul_q15(q15_t *pSrc,q15_t *scale,uint32_t blockSize, typ_data_t typ_data,uint16_t inBank, uint16_t outBank );

void rsi_fim_interrupt_handler(volatile FIM_Type *ptFim);

void rsi_arm_add_f32_opt( int32_t *pSrcA, int32_t *pSrcB,uint32_t blockSize, uint16_t inBank1, uint16_t inBank2, uint16_t outBank);
                      
void rsi_arm_add_q7_opt( q7_t *pSrcA, q7_t *pSrcB,  q7_t *pDst,  uint32_t blockSize, uint16_t inBank1, uint16_t inBank2, uint16_t outBank);
                                                          
void rsi_arm_add_q15_opt( q15_t *pSrcA,  q15_t *pSrcB,  q15_t *pDst,  uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);
                                                           
void rsi_arm_add_q31_opt( q31_t *pSrcA, q31_t *pSrcB, q31_t *pDst,uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank); 
                                                                 
void rsi_fim_vector_add_q15(q15_t *pIn1, q15_t *pIn2,q15_t *pDst,uint32_t blockSize, typ_data_t typ_data,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_arm_sub_f32_opt( int32_t *pSrcA, int32_t *pSrcB,int32_t *pDst, uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank );
                      
void rsi_arm_sub_q7_opt( q7_t *pSrcA,  q7_t *pSrcB,q7_t *pDst,uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank );  
                    
void rsi_arm_sub_q15_opt( q15_t *pSrcA,  q15_t *pSrcB, q15_t *pDst, uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);  
                     
void rsi_arm_sub_q31_opt( q31_t *pSrcA,  q31_t *pSrcB,q31_t *pDst, uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);  
                     
void rsi_fim_read_data( uint32_t bank,uint32_t length,volatile void *pDst,uint8_t data_type,typ_data_t type_data); 
                       
void rsi_fim_vector_sub_q15( q15_t *pIn1, q15_t *pIn2,q15_t *pDst,uint32_t blockSize,typ_data_t typ_data,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_arm_mult_f32_opt( int32_t *pIn1, int32_t *pIn2,uint32_t SatTruncRound, uint32_t length,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);
                       
void rsi_arm_mult_q7_opt( q7_t *pSrcA, q7_t *pSrcB, q7_t *pDst, uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_arm_mult_q15_opt( q15_t *pSrcA, q15_t *pSrcB, q15_t *pDst, uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_arm_mult_q31_opt(q31_t *pSrcA,q31_t *pSrcB,q31_t *pDst,uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_fim_vector_mul_q15( q15_t *pIn1, q15_t *pIn2,q15_t *pDst,uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);
                               
void rsi_arm_cmplx_mult_real_q15_opt(q15_t *pSrcCmplx,q15_t *pSrcReal,q15_t *pDst,uint32_t numSamples,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_arm_cmplx_mult_cmplx_q15_opt(q15_t * pSrcA,q15_t * pSrcB,q15_t *pDst,uint32_t numSamples,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_arm_cmplx_mag_squared_q15_opt(q15_t *pSrc,q15_t *pDst,uint32_t numSamples,uint16_t inBank, uint16_t outBank);

void rsi_fim_absSqr_q7( q7_t *pSrc,
                     uint32_t length,uint16_t inBank, uint16_t outBank);
void rsi_fim_absSqr_q15( q15_t *pSrc,
                     uint32_t length,uint16_t inBank, uint16_t outBank);
void rsi_fim_absSqr_q31( q31_t *pSrc,
                     uint32_t length,uint16_t inBank, uint16_t outBank);
void rsi_fim_absSqr_f32( int32_t *pSrc,
                        uint32_t length,uint16_t inBank, uint16_t outBank);

error_t rsi_arm_mat_mult_f32_opt( const arm_matrix_instance_f32_opt *pSrcA,  
                              const arm_matrix_instance_f32_opt *pSrcB,
                              arm_matrix_instance_f32_opt *pDst,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

error_t rsi_arm_mat_mult_q31_opt(const arm_matrix_instance_q31_opt * pSrcA,const arm_matrix_instance_q31_opt * pSrcB,
                                 arm_matrix_instance_q31_opt * pDst,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

error_t rsi_arm_mat_mult_q15_opt( const arm_matrix_instance_q15_opt * pSrcA,
                              const arm_matrix_instance_q15_opt * pSrcB,arm_matrix_instance_q15_opt * pDst,q15_t * pState
                                ,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);


void rsi_arm_fir_init_f32_opt( arm_fir_instance_f32_opt *S,
                           uint16_t numTaps,
                           int32_t *pCoeffs,
                           int32_t *pState,
                           uint32_t blockSize);

void rsi_arm_fir_f32_opt( arm_fir_instance_f32_opt *S, 
                      int32_t *pSrc,
                      int32_t *pDst,
                      uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_arm_fir_init_q31_opt( arm_fir_instance_q31_opt *S,uint16_t numTaps,q31_t *pCoeffs,
                           q31_t *pState, uint32_t blockSize);

void rsi_arm_fir_q31_opt( arm_fir_instance_q31_opt *S, q31_t *pSrc,q31_t *pDst, uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_arm_fir_init_q15_opt( arm_fir_instance_q15_opt *S,uint16_t numTaps,q15_t *pCoeffs,
                           q15_t *pState, uint32_t blockSize);

void rsi_arm_fir_q15_opt( arm_fir_instance_q15_opt *S, q15_t *pSrc,q15_t *pDst, uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_fim_fir_q15( arm_fir_instance_q15_opt *S, q15_t *pSrc,q15_t *pDst,uint32_t blockSize,typ_data_t typ_data,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_arm_fir_init_q7_opt( arm_fir_instance_q7_opt *S,uint16_t numTaps,q7_t *pCoeffs,
                          q7_t *pState, uint32_t blockSize);

void rsi_arm_fir_q7_opt( arm_fir_instance_q7_opt *S, q7_t *pSrc,q7_t *pDst, 
                       uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);


void rsi_fim_Iir_init_f32( fim_iir_instance_f32 *S,
                           uint16_t numStages, 
                           int32_t *pCoeffs,
                           int32_t *pvCoeffs,
                           int32_t *pState);

void rsi_fim_Iir_init_q31( fim_iir_instance_q31 *S,uint16_t numStages, q31_t *pCoeffs,
                           q31_t *pvCoeffs,uint32_t *pState);

void rsi_fim_Iir_q31( fim_iir_instance_q31 *S, int32_t *pSrc,
                      q31_t *pDst,uint32_t blockSize,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_fim_Iir_init_q15( fim_iir_instance_q15 *S,uint16_t numStages, 
                           q15_t *pCoeffs,q15_t *pvCoeffs,q15_t *pState);

void rsi_fim_Iir_q15( fim_iir_instance_q15 *S,q15_t *pSrc,q15_t *pDst,
                      uint32_t blockSize, typ_data_t typ_data,uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_fim_Iir_f32( fim_iir_instance_f32 *S,
                      int32_t *pSrc,
                      int32_t *pDst,
                      uint32_t length, 
                      uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_arm_fir_interpolate_f32_opt( const arm_fir_interpolate_instance_f32_opt * S,
                                  int32_t * pSrc,
                                  int32_t * pDst,
                                  uint32_t blockSize,
                                  uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

arm_status rsi_arm_fir_interpolate_init_f32_opt( arm_fir_interpolate_instance_f32_opt * S,
                                             uint8_t L, uint16_t numTaps,
                                             int32_t * pCoeffs,
                                             int32_t * pState,
                                             uint32_t blockSize );

arm_status rsi_arm_fir_interpolate_init_q15_opt( arm_fir_interpolate_instance_q15_opt * S,
                                             uint8_t L,
                                             uint16_t numTaps,
                                             q15_t * pCoeffs,
                                             q15_t * pState,
                                             uint32_t blockSize );

arm_status rsi_arm_fir_interpolate_init_q31_opt( arm_fir_interpolate_instance_q31_opt *S,
                                             uint8_t L,
                                             uint16_t numTaps,
                                             q31_t * pCoeffs,
                                             q31_t * pState,
                                             uint32_t blockSize );

void rsi_arm_fir_interpolate_q15_opt( arm_fir_interpolate_instance_q15_opt * S,
                                  q15_t * pSrc, q15_t *pDst,
                                  uint32_t blockSize,
                                  uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_fim_fir_interpolate_q15( arm_fir_interpolate_instance_q15_opt *S,
                                  q15_t * pSrc,q15_t *pDst,
                                  uint32_t blockSize,typ_data_t typ_data,
                                  uint16_t inBank1, uint16_t inBank2, uint16_t outBank);

void rsi_arm_fir_interpolate_q31_opt( const arm_fir_interpolate_instance_q31_opt * S,
                                  q31_t * pSrc,
                                  q31_t * pDst,
                                  uint32_t blockSize,
                                  uint16_t inBank1, uint16_t inBank2, uint16_t outBank );


/*End of file not truncated*/
#ifdef __cplusplus
}
#endif
#endif // __RSI_FIM_H__

